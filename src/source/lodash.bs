namespace _
  '*************************************************************************
  '#region *** ARRAY
  '*************************************************************************

  ' /**
  ' * @name chunk
  ' * @description Creates an array of elements split into groups the length of size. If array can't be split evenly, the final chunk will be the remaining elements.
  ' * @param {Array} array - The array to process
  ' * @param {Integer} size - The length of each chunk
  ' * @return {Array} Returns the new array of chunks
  ' */
  function chunk(array = [] as object, size = 1 as integer) as object
    numberOfChunks = array.count() / size
    returnArray = CreateObject("roArray", numberOfChunks, true)

    arrayIndex = 0
    for index = 0 to numberOfChunks
      chunkArray = []

      for chunkSize = 0 to size - 1
        chunkArray.push(array[arrayIndex])
        arrayIndex ++
        if arrayIndex = array.count() then exit for
      end for
      returnArray[index] = chunkArray
      if arrayIndex = array.count() then exit for
    end for

    return returnArray
  end function

  ' /**
  ' * @name compact
  ' * @description Creates an array with all falsey values removed. The values false, 0, "", and invalid are falsey.
  ' * @param {Array} array - The array to compact
  ' * @return {Array} Returns the new array of filtered values
  ' */
  function compact(array = [] as object) as object
    returnArray = []

    for each item in array
      shallPass = true
      typeName = type(item)

      if item = invalid then
        shallPass = false
      else if typeName = "roString" then
        if item = "" then shallPass = false
      else if typeName = "roInteger" then
        if item = 0 then shallPass = false
      else if typeName = "roBoolean" then
        shallPass = item
      end if

      if shallPass then returnArray.push(item)
    end for
    return returnArray
  end function

  ' /**
  ' * @name concat
  ' * @description Creates a new array concatenating array with any additional arrays and/or values.
  ' * @param {Array} array - The array to concatenate
  ' * @param {Array} values - The values to concatenate
  ' * @return {Array} Returns the new concatenated array
  ' */
  function concat(array = [] as object, values = [] as object) as object
    returnArray = []
    returnArray.append(array)
    returnArray.append(values)
    return returnArray
  end function

  ' /**
  ' * @name difference
  ' * @description Creates an array of array values not included in the other given arrays using SameValueZero for equality comparisons. The order and references of result values are determined by the first array.
  ' * @param {Array} array - The array to inspect
  ' * @param {Array} values - The values to exclude
  ' * @return {Array} Returns the new array of filtered values
  ' */
  function difference(array = [] as object, values = [] as object) as object
    return _.differenceBy(array, values)
  end function

  ' /**
  ' * @name differenceBy
  ' * @description This method is like _.difference except that it accepts iteratee which is invoked for each element of array and values to generate the criterion by which they're compared. The order and references of result values are determined by the first array. The iteratee is invoked with one argument:(value).
  ' * @param {Array} array - The array to inspect
  ' * @param {Array} values - The values to exclude
  ' * @param {Dynamic} iteratee - The iteratee invoked per element
  ' * @return {Array} Returns the new array of filtered values
  ' */
  function differenceBy(array = [] as object, values = [] as object, iteratee = invalid) as object
    iterateeIsFunction = _.isFunction(iteratee)
    iterateeIsProperty = NOT iterateeIsFunction AND _.isString(iteratee)

    returnArray = []
    for each item in array
      convertedItem = item
      if iterateeIsFunction then
        convertedItem = iteratee(item)
      else if iterateeIsProperty then
        convertedItem = item[iteratee]
      end if
      found = false

      for each valueToMatch in values
        if iterateeIsFunction then
          valueToMatch = iteratee(valueToMatch)
        else if iterateeIsProperty
          valueToMatch = valueToMatch[iteratee]
        end if
        if convertedItem = valueToMatch then found = true : exit for
      end for

      if NOT found then returnArray.push(item)
    end for

    return returnArray
  end function

  ' /**
  ' * @name differenceWith
  ' * @description This method is like _.difference except that it accepts comparator which is invoked to compare elements of array to values. The order and references of result values are determined by the first array. The comparator is invoked with two arguments: (arrVal, othVal).
  ' * @param {Array} array - The array to inspect
  ' * @param {Array} values - The values to exclude
  ' * @param {Dynamic} iteratee - The iteratee invoked per element
  ' * @return {Array} Returns the new array of filtered values
  ' */
  function differenceWith(array = [] as object, values = [] as object, comparator = invalid) as object
    returnArray = []

    if _.isFunction(comparator) then
      for i = 0 to array.count() - 1
        itemOne = array[0]
        itemTwo = array[1]

        if _.isNotInvalid(itemOne) AND _.isNotInvalid(itemTwo) AND NOT _.isEqual(itemOne, itemTwo) then returnArray.push(itemOne)
      end for
    end if

    return returnArray
  end function

  ' /**
  ' * @name drop
  ' * @description Creates a slice of array with n elements dropped from the beginning.
  ' * @param {Array} array - The array to query
  ' * @param {Integer} n - The number of elements to drop
  ' * @return {Array} Returns the slice of array
  ' */
  function drop(array = {} as object, n = 1 as integer)
    array = _.clone(array)
    for i = 0 to n -1
      array.shift()
      if array.count() = 0 then exit for
    end for

    return array
  end function

  ' /**
  ' * @name dropRight
  ' * @description Creates a slice of array with n elements dropped from the end.
  ' * @param {Array} array - The array to query
  ' * @param {Integer} n - The number of elements to drop
  ' * @return {Array} Returns the slice of array
  ' */
  function dropRight(array = {} as object, n = 1 as integer)
    array = _.clone(array)
    array.reverse()
    array = _.drop(array, n)
    array.reverse()
    return array
  end function

  ' /**
  ' * @name dropRightWhile
  ' * @description Creates a slice of array excluding elements dropped from the end. Elements are dropped until predicate returns falsey. The predicate is invoked with three arguments: (value, index, array).
  ' * @param {Array} array - The array to query
  ' * @param {Dynamic} predicate - The function invoked per iteration
  ' * @return {Array} Returns the slice of array
  ' */
  function dropRightWhile(array = {} as object, predicate = invalid)
    array = _.clone(array)
    array.reverse()
    array = _.dropWhile(array, predicate)
    array.reverse()
    return array
  end function

  '/**
  ' * @name dropWhile
  ' * @description Creates a slice of array excluding elements dropped from the beginning. Elements are dropped until predicate returns falsey. The predicate is invoked with three arguments: (value, index, array).
  ' * @param {Array} array - The array to query
  ' * @param {Dynamic} predicate - The function invoked per iteration
  ' * @return {Array} Returns the slice of array
  ' */
  function dropWhile(array = [] as object, predicate = invalid)
    array = _.clone(array)
    for i = 0 to array.count() - 1
      item = array[i]

      if _.isFunction(predicate) then
        if NOT predicate(item) then return _.slice(array, i)
      else if _.isAA(predicate) then
        if NOT _.isEqual(item, predicate) then return _.slice(array, i)
      else if _.isArray(predicate) then
        if NOT _.isEqual(item[predicate[0]], predicate[1]) then return _.slice(array, i)
      else if _.isString(predicate) then
        if NOT item[predicate] then return _.slice(array, i)
      end if
    end for

    return array
  end function

  '/**
  ' * @name fill
  ' * @description Fills elements of array with value from start up to, but not including, end.
  ' * This method mutates array. 
  ' * @param {Array} array - The array to fill
  ' * @param {Dynamic} value - The value to fill array with
  ' * @param {Integer} startPos - The start position
  ' * @param {Integer} endPos - The end position
  ' * @return {Array} Returns the mutated array
  ' */
  function fill(array = [] as object, value = "" as dynamic, startPos = 0, endPos = invalid)
    if _.isInvalid(endPos) then endPos = array.count()
    endPos = endPos - 1

    for i = startPos to endPos
      array[i] = value
    end for
    return array
  end function

  '/**
  ' * @name findIndex
  ' * @description This method is like _.find except that it returns the index of the first element predicate returns truthy for instead of the element itself.
  ' * @param {Array} array - The array to inspect
  ' * @param {Dynamic} predicate - The function invoked per iteration
  ' * @param {Integer} fromIndex - The index to search from
  ' * @return {Integer} Returns the index of the found element, else -1
  ' */
  function findIndex(array, predicate = invalid as dynamic, fromIndex = 0 as integer) as integer
    for index = fromIndex to array.count() -1
      item = array[index]

      if _.isFunction(predicate) then
        if predicate(item) then return index
      else if _.isAA(predicate) then
        if _.isEqual(item, predicate) then return index
      else if _.isArray(predicate) then
        if _.isEqual(item[predicate[0]], predicate[1]) then return index
      else if _.isString(predicate) then
        if item[predicate] then return index
      end if
    end for

    return -1
  end function

  '/**
  ' * @name findLastIndex
  ' * @description This method is like _.findIndex except that it iterates over elements of collection from right to left.
  ' * @param {Array} array - The array to inspect
  ' * @param {Dynamic} predicate - The function invoked per iteration
  ' * @param {Integer} fromIndex - The index to search from
  ' * @return {Integer} Returns the index of the found element, else -1
  ' */
  function findLastIndex(array, predicate = invalid, fromIndex = 0 as integer)
    array = _.clone(array)
    array.reverse()
    foundIndex = _.findIndex(array, predicate, fromIndex)

    if foundIndex = -1 then return -1
    return array.count() - 1 - foundIndex
  end function

  '/**
  ' * @name first
  ' * @description An alias to the head function.
  ' * @param {Array} array - The array to query
  ' * @return {Dynamic} Returns the first element of array
  ' */
  function first(array = [])
    return _.head(array)
  end function

  '/**
  ' * @name flatten
  ' * @description Flattens array a single level deep.
  ' * @param {Array} array - The array to flatten
  ' * @return {Dynamic} Returns the new flattened array
  ' */
  function flatten(array = [])
    returnArray = []
    for each item in array
      if type(item) = "roArray" then
        returnArray.append(item)
      else
        returnArray.push(item)
      end if
    end for
    return returnArray
  end function

  '/**
  ' * @name flattenDeep
  ' * @description Recursively flattens array.
  ' * @param {Array} array - The array to flatten
  ' * @return {Dynamic} Returns the new flattened array
  ' */
  function flattenDeep(array = [])
    returnArray = []
    for each item in array
      if type(item) = "roArray" then
        returnArray.append(_.flattenDeep(item))
      else
        returnArray.push(item)
      end if
    end for
    return returnArray
  end function

  '/**
  ' * @name head
  ' * @description Gets the first element of array.
  ' * @param {Array} array - The array to query
  ' * @return {Dynamic} Returns the first element of array
  ' */
  function head(array = []) as dynamic
    return array[0]
  end function

  '/**
  ' * @name indexOf
  ' * @description Gets the index at which the first occurrence of value is found in array using SameValueZero for equality comparisons. If fromIndex is negative, it's used as the offset from the end of array.
  ' * @param {Array} array - The array to inspect
  ' * @param {Dynamic} value - The value to search for
  ' * @param {Integer} fromIndex - The index to search from
  ' * @return {Integer} Returns the index of the matched value, else -1
  ' */
  function indexOf(array = [] as object, value = invalid, fromIndex = 0)
    if NOT _.isArray(array) then return -1

    for index = fromIndex to array.count() -1
      item = array[index]
      if _.isEqual(item, value) then return index
    end for

    return -1
  end function

  '/**
  ' * @name initial
  ' * @description Gets all but the last element of array.
  ' * @param {Array} array - The array to query
  ' * @return {Array} Returns the slice of array
  ' */
  function initial(array = [] as object)
    if NOT _.isArray(array) then return []
    return _.slice(array, 0, array.count() - 1)
  end function

  '/**
  ' * @name intersection
  ' * @description Creates an array of unique values that are included in all given arrays using SameValueZero for equality comparisons. The order and references of result values are determined by the first array.
  ' * @param {Array} mainArray - The main array to inspect
  ' * @param {Array} inspect - The array to find matches
  ' * @return {Array} Returns the new array of intersecting values
  ' */
  function intersection(mainArray = [] as object, inspectArray = [] as object) as object
    return _.intersectionBy(mainArray, inspectArray)
  end function

  '/**
  ' * @name intersectionBy
  ' * @description This method is like _.intersection except that it accepts iteratee which is invoked for each element of each arrays to generate the criterion by which they're compared. The order and references of result values are determined by the first array. The iteratee is invoked with one argument:(value).
  ' * @param {Array} mainArray - The main array to inspect
  ' * @param {Array} inspect - The array to find matches
  ' * @param {Dynamic} iteratee - The iteratee invoked per element
  ' * @return {Array} Returns the new array of intersecting values
  ' */
  function intersectionBy(mainArray = [] as object, inspectArray = [] as object, iteratee = invalid) as object
    intersectArray = []

    mainArray = _.clone(mainArray)
    inspectArray = _.clone(inspectArray)

    if _.isInvalid(iteratee) then
      if _.isNonEmptyArray(mainArray) then
        for each item in mainArray
          if NOT _.isEqual(_.indexOf(inspectArray, item), - 1) then intersectArray.push(item)
        end for
      end if
    else if _.isFunction(iteratee) then
      for i = 0 to inspectArray.count() - 1
        inspectArray[i] = iteratee(inspectArray[i])
      end for
      for each item in mainArray
        if NOT _.isEqual(_.indexOf(inspectArray, iteratee(item)), - 1) then intersectArray.push(item)
      end for
    else if _.isString(iteratee) then
      for each item in mainArray
        findKey = item[iteratee]
        if _.isNotInvalid(findKey) then
          matchValue = {}
          matchValue[iteratee] = findKey
          if NOT _.isEqual(_.findIndex(inspectArray, matchValue), - 1) then intersectArray.push(item)
        end if
      end for
    end if

    return intersectArray
  end function

  '/**
  ' * @name intersectionWith
  ' * @description This method is like _.intersection except that it accepts comparator which is invoked to compare elements of arrays. The order and references of result values are determined by the first array. The comparator is invoked with two arguments: (arrVal, othVal).
  ' * @param {Array} mainArray - The main array to inspect
  ' * @param {Array} inspect - The array to find matches
  ' * @param {Dynamic} comparator - The comparator invoked per element
  ' * @return {Array} Returns the new array of intersecting values
  ' */
  function intersectionWith(mainArray = [] as object, inspectArray = [] as object, comparator = invalid) as object
    if NOT _.isFunction(comparator) then return []
    return _.intersectionBy(mainArray, inspectArray, comparator)
  end function


  '/**
  ' * @name join
  ' * @description Converts all elements in array into a string separated by separator.
  ' * @param {Array} array - The array to convert
  ' * @param {String} separator - The element separator
  ' * @return {Array} Returns the joined string
  ' */
  function join(array = [] as object, separator = "" as string)
    return _.clone(array).join(separator)
  end function

  '/**
  ' * @name last
  ' * @description Gets the last element of array.
  ' * @param {Array} array - The array to query
  ' * @return {Dynamic} Returns the last element of array
  ' */
  function last(array = []) as dynamic
    return array[array.count() - 1]
  end function

  '/**
  ' * @name slice
  ' * @description Creates a slice of array from start up to, but not including, end.
  ' * @param {Array} array - The array to slice
  ' * @param {Integer} startPos - The start position
  ' * @param {Integer} endPos - The end position
  ' * @return {Dynamic} Returns the slice of array
  ' */
  function slice(array = [] as object, startPos = 0, endPos = invalid)
    if NOT _.isArray(array) then return invalid
    if _.isNotInvalid(endPos) then endPos = endPos - 1

    array = _.clone(array)
    size = array.count()
    lastIndex = size - 1
    slicedArray = []

    if startPos < 0 then startPos = size + startPos
    if endPos = invalid then endPos = lastIndex
    if endPos < 0 then endPos = size + endPos
    if endPos >= size then endPos = lastIndex

    if startPos >= size OR startPos > endPos then return slicedArray

    for i = startPos to endPos
        slicedArray.push(array[i])
    end for

    return slicedArray
  end function

  '/**
  ' * @name sortedIndex
  ' * @description Gets all but the first element of array
  ' * @param {Array} array - The sorted array to inspect
  ' * @return {Object} Returns the index at which value should be inserted into array
  ' */
  function sortedIndex(array = [] as object, value = 0 as integer)
    for i = 0 to array.count() - 1
      item = array[i]
      nextItem = array[i + 1]
      if _.isNotInvalid(nextItem) then
        if (item >= value AND value <= nextItem) then
          return i
        end if
      end if
    end for

    return i
  end function

  '/**
  ' * @name tail
  ' * @description Uses a binary search to determine the lowest index at which value should be inserted into array in order to maintain its sort order.
  ' * @param {Array} array - The sorted array to query
  ' * @return {Object} Returns the slice of array
  ' */
  function tail(array = [] as object) as object
    if NOT _.isNonEmptyArray(array) then return []
    return _.slice(array, 1)
  end function

  '/**
  ' * @name take
  ' * @description Creates a slice of array with n elements taken from the beginning
  ' * @param {Array} array - The sorted array to query
  ' * @param {Integer} n - The number of elements to take
  ' * @return {Object} Returns the slice of array
  ' */
  function take(array = [] as object, n = invalid as dynamic) as object
    if _.isInvalid(n) then n = 1
    if NOT _.isNonEmptyArray(array) OR n = 0 then return []
    return _.slice(array, 0, n)
  end function

  '/**
  ' * @name takeRight
  ' * @description Creates a slice of array with n elements taken from the end
  ' * @param {Array} array - The sorted array to query
  ' * @param {Integer} n - The number of elements to take
  ' * @return {Object} Returns the slice of array
  ' */
  function takeRight(array = [] as object, n = invalid as dynamic) as object
    if _.isInvalid(n) then n = 1
    if NOT _.isNonEmptyArray(array) OR n = 0 then return []

    length = array.count()
    startPos = length - n
    if startPos < 0 then startPos = 0
    return _.slice(array, startPos, length)
  end function

  '/**
  ' * @name union
  ' * @description Creates a slice of array with n elements taken from the end
  ' * @param {Array} arrays - The arrays to inspect
  ' * @return {Object} Returns the new array of combined values
  ' */
  function union(arrays = [] as object) as object
    return _.uniq(_.flattenDeep(arrays))
  end function

  '/**
  ' * @name uniq
  ' * @description Creates a duplicate-free version of an array, using SameValueZero for equality comparisons, in which only the first occurrence of each element is kept. The order of result values is determined by the order they occur in the array.
  ' * @param {Array} array - The array to inspect
  ' * @return {Object} Returns the new duplicate free array
  ' */
  function uniq(array = [] as object) as object
    returnArray = []
    table = {}
    for each item in array
      key = item.toStr()
      if not table.doesExist(key)
        returnArray.push(item)
        table[key] = true
      end if
    end for
    return returnArray
  end function

  '/**
  ' * @name zip
  ' * @description Creates an array of grouped elements, the first of which contains the first elements of the given arrays, the second of which contains the second elements of the given arrays, and so on.
  ' * @param {Array} arrays - The property identifiers
  ' * @return {Object} Returns the new array of grouped elements
  ' */
  function zip(arrays = [] as object) as object
    returnArray = []

    for i = 0 to arrays.count() - 1
      array = arrays[i]
      for ii = 0 to array.count() - 1
        if _.isInvalid(returnArray[ii]) then returnArray[ii] = []
        returnArray[ii].push(array[ii])
      end for
    end for

    return returnArray
  end function

  '/**
  ' * @name zipObject
  ' * @description This method is like _.fromPairs except that it accepts two arrays, one of property identifiers and one of corresponding values.
  ' * @param {Array} array - The property identifiers
  ' * @param {Array} values - The property identifiers
  ' * @return {Object} Returns the new object
  ' */
  function zipObject(props = [] as object, values = [] as object) as object
    returnObject = {}

    for i = 0 to props.count() - 1
      returnObject[props[i]] = values[i]
    end for

    return returnObject
  end function

  '/**
  ' * @name zipObjectDeep
  ' * @description This method is like _.zipObject except that it supports property paths.
  ' * @param {Array} array - The property identifiers
  ' * @param {Array} values - The property identifiers
  ' * @return {Object} Returns the new object
  ' */
  function zipObjectDeep(props = [] as object, values = [] as object) as object
   ' COME BACK
  end function


  '*************************************************************************
  '#endregion *** ARRAY
  '*************************************************************************


  '*************************************************************************
  '#region *** COLLECTION
  '*************************************************************************

  ' /**
  ' * @name forEach
  ' * @description Iterates over elements of collection and invokes iteratee for each element. The iteratee is invoked with three arguments: (value, index|key, collection). Iteratee functions may exit iteration early by explicitly returning false.
  ' * TODO: Note: As with other "Collections" methods, objects with a "length" property are iterated like arrays. To avoid this behavior use _.forIn or _.forOwn for object iteration.
  ' * @param {Dynamic} collection - The collection to iterate over
  ' * @param {Dynamic} iteratee - The function invoked per iteration
  ' * @return {Dynamic} Returns collection
  ' */
  function forEach(collection = invalid as dynamic, iteratee = invalid as dynamic)
    return _.base.forEach.baseForEach(collection, iteratee)
  end function

  ' /**
  ' * @name forEachRight
  ' * @description This method is like _.forEach except that it iterates over elements of collection from right to left.
  ' * @param {Dynamic} collection - The collection to iterate over
  ' * @param {Dynamic} iteratee - The function invoked per iteration
  ' * @return {Dynamic} Returns collection
  ' */
  function forEachRight(collection = invalid as dynamic, iteratee = invalid as dynamic)
    return _.base.forEach.baseForEach(collection, iteratee, "right")
  end function

  ' /**
  ' * @name reduce
  ' * @description Reduces collection to a value which is the accumulated result of running each element in collection thru iteratee, where each successive invocation is supplied the return value of the previous. If accumulator is not given, the first element of collection is used as the initial value. The iteratee is invoked with four arguments:(accumulator, value, index|key, collection).
  ' * @param {Dynamic} collection - The collection to iterate over
  ' * @param {Dynamic} iteratee - The function invoked per iteration
  ' * @param {Integer} accumulator - The initial value
  ' * @return {Array} Returns the accumulated value
  ' */
  function reduce(collection = invalid as dynamic, iteratee = invalid as dynamic, accumulator = invalid as dynamic)
    result = accumulator

    if _.isInvalid(iteratee) then
      return collection
    else if _.isFunction(iteratee) then
      if _.isArray(collection) then
        for each item in collection
          result = iteratee(result, item)
        end for
      else if _.isAA(collection) then
        for each key in collection.keys()
          item = collection[key]
          result = iteratee(result, item, key)
        end for
      end if
    end if

    return result
  end function

  ' /**
  ' * @name shuffle
  ' * @description Creates an array of shuffled values, using a version of the Fisher-Yates shuffle.
  ' * @param {Dynamic} collection - The collection to shuffle
  ' * @return {Array} Returns the new shuffled array
  ' */
  function shuffle(collection = [] as dynamic)
    if _.isInvalid(collection) OR (NOT _.isArray(collection) AND NOT _.isAA(collection)) then return []
    if _.isAA(collection) then collection = _.aaToArray(collection)

    length = collection.count() - 1
    if _.isEqual(length, -1) then return []

    index = -1
    lastIndex = length - 1
    result = _.clone(collection)

    while index < length
      index ++
      rand = index + _.floor(_.random(0, 1, true) * (lastIndex - index + 1))
      value = result[rand]
      result[rand] = result[index]
      result[index] = value
    end while

    return result
  end function

  ' /**TODO:
  ' * @name size
  ' * @description Creates an array of shuffled values, using a version of the Fisher-Yates shuffle.
  ' * @param {Dynamic} collection - The collection to shuffle
  ' * @return {Array} Returns the new shuffled array
  ' */
  function size(collection = invalid as dynamic)
    if _.isInvalid(collection) OR (NOT _.isArray(collection) AND NOT _.isAA(collection) AND NOT _.isString(collection)) then return []
    if _.isAA(collection) then
      collection = _.aaToArray(collection)
    else if _.isString(collection) then
      return collection.len()
    end if

    return collection.count()
  end function

  ' /**
  ' * @name softBy
  ' * @description Creates an array of elements, sorted in ascending order by the results of running each element in a collection thru each iteratee. This method performs a stable sort, that is, it preserves the original sort order of equal elements. The iteratees are invoked with one argument: (value).
  ' * @param {Dynamic} collection - The collection to shuffle
  ' * @param {Dynamic} iteratee - The iteratees to sort by
  ' * @return {Array} Returns the new sorted array
  ' */
  function sortBy(collection = invalid as dynamic, iteratee = invalid as dynamic)
    if _.isInvalid(collection) OR NOT _.isArray(collection) then return collection
    returnCollection = _.clone(collection)

    if _.isArray(iteratee) then
      for each iteration in iteratee
        if _.isString(iteration) then returnCollection.sortBy(iteration)
      end for
    else if _.isFunction(iteratee) then
      key = ""
      for each aa in collection
        for each key in aa.keys()
          if _.isEqual(aa[key], iteratee(aa)) then exit for
        end for

        if NOT key = "" then exit for
      end for

      if NOT key = "" then returnCollection.sortBy(key)
    end if

   return returnCollection
  end function

  ' /**
  ' * @name map
  ' * @description Creates an array of values by running each element in collection thru iteratee. The iteratee is invoked with three arguments:(value, index|key, collection)
  ' * @param {Dynamic} collection - The collection to iterate over
  ' * @param {Dynamic} iteratee - The function invoked per iteration
  ' * @return {Array} Returns the new mapped array
  ' */
  function map(collection = {} as dynamic, iteratee = invalid as dynamic)
    if NOT _.isArray(collection) then return []

    returnArray = []

    for each item in collection
      if _.isString(iteratee) then
        if _.isAA(item) then returnArray.push(item[iteratee])
      else if _.isFunction(iteratee) then
        returnArray.push(iteratee(item))
      end if
    end for

    return returnArray
  end function

  '*************************************************************************
  '#endregion *** COLLECTION
  '*************************************************************************


  '*************************************************************************
  '#region *** FUNCTION
  '*************************************************************************

  ' /** TODO:
  ' * @name after
  ' * @description The opposite of _.before; this method creates a function that invokes func once it's called n or more times.
  ' * @param {Integer} n - The number of calls before func is invoked
  ' * @param {Dynamic} func - The function to restrict
  ' * @return {Dynamic} Returns the new restricted function
  ' */
  function after(n = 0 as integer, func = invalid as dynamic)

    ' console.log("howdy")

    ' returnFunc = function(n, func)
    '   functionIdentifier = func.toStr()
    '   if _.isInvalid(m[functionIdentifier]) then m[functionIdentifier] = 0
    '   _.nope()

    '   return func
    ' end function

    ' return returnFunc(n, func)
    return invalid
  end function


  function ary(func = invalid as dynamic, n = 0 as integer)
    if _.isNotInvalid(func) then
      for i = 1 to n
        return func
      end for
      ' if _.isInvalid(_[func]) then
    end if
  end function

  '*************************************************************************
  '#endregion *** FUNCTION
  '*************************************************************************


  '*************************************************************************
  '#region *** LANG
  '*************************************************************************

  ' /**
  ' * @name canBeCompared
  ' * @description Checks if the supplied values can be compared in a if statement.
  ' * @param {Dynamic} valueOne - First value
  ' * @param {Dynamic} valueTwo - Second value
  ' * @return {Boolean} True if the values can be compared in a if statement
  ' */
  function canBeCompared(valueOne as Dynamic, valueTwo as Dynamic) as Boolean
    ' If the first argument is true we don't need to check the following conditionals
    if _.isString(valueOne) then
      if _.isString(valueTwo) then return true
    else if _.isNumber(valueOne) then
      if _.isNumber(valueTwo) then return true
    else if _.isBoolean(valueOne) then
      if _.isBoolean(valueTwo) then return true
    else if _.isInvalid(valueOne) then
      if _.isInvalid(valueTwo) then return true
    end if

    return false
  end function

  function castArray(value as dynamic) as object
    return []
  end function

  ' /**
  ' * @name clone
  ' * @description Clones objects that can be cloned.
  ' * @param {Dynamic} value - The value to be cloned
  ' * @return {Dynamic} The cloned value
  ' */
  function clone(value = invalid as dynamic) as dynamic
    if _.isInvalid(value) return invalid

    clonedValue = invalid
    if _.isString(value) then
      clonedValue = "" + value
    else if _.isAA(value) then
      clonedValue = CreateObject("roAssociativeArray")
      clonedValue.append(value)
    else if _.isArray(value) then
      clonedValue = CreateObject("roArray", value.count(), true)
      clonedValue.append(value)
    else if _.isNumber(value) then
      clonedValue = 0 + value
    else if _.isBoolean(value) then
      clonedValue = false OR value
    else if _.isNode(value) then
      clonedValue = value.clone(true)
    end if

    return clonedValue
  end function

  ' TODO
  function cloneDeep() as dynamic
    return []
  end function

  ' TODO
  function cloneDeepWith() as dynamic
    return []
  end function

  ' TODO
  function conformsTo() as dynamic
    return []
  end function

  function eq(value as dynamic, other as dynamic)
    return _.isEqual(value, other)
  end function

  function gt(value as dynamic, other as dynamic)
    return value > other
  end function

  function gte(value as dynamic, other as dynamic)
    return value >= other
  end function

  ' TODO
  function isArguments(value as dynamic)
    return false
  end function

  ' /**
  ' * @name isAA
  ' * @description Checks if the supplied value is a valid AssociativeArray type
  ' * @param {Dynamic} value The variable to be checked
  ' * @return {Boolean} Results of the check
  ' */
  function isAA(value as dynamic)
    return type(value) = "roAssociativeArray"
  end function

  ' /**
  ' * @name isKeyedValueType
  ' * @description Checks if the supplied value allows for key field access
  ' * @param {Dynamic} value The variable to be checked
  ' * @return {Boolean} Results of the check
  ' */
  function isKeyedValueType(value as Dynamic) as Boolean
    return getInterface(value, "ifAssociativeArray") <> Invalid
  end function

  ' /**
  ' * @name isFunction
  ' * @description Checks if the supplied value is a valid Function type
  ' * @param {Dynamic} value The variable to be checked
  ' * @return {Boolean} Results of the check
  ' */
  function isFunction(value as Dynamic) as Boolean
    valueType = type(value)
    return (valueType = "roFunction") OR (valueType = "Function")
  end function

  ' /**
  ' * @name isNonEmptyAA
  ' * @description Checks if the supplied value is a valid and populated AssociativeArray type
  ' * @param {Dynamic} value The variable to be checked
  ' * @return {Boolean} Results of the check
  ' */
  function isNonEmptyAA(value as dynamic)
    return _.isAA(value) AND value.keys().count() > 0
  end function

  ' /**
  ' * @name isArray
  ' * @description Checks if the supplied value is a valid Array type
  ' * @param {Dynamic} value The variable to be checked
  ' * @return {Boolean} Results of the check
  ' */
  function isArray(value as dynamic)
    return type(value) = "roArray"
  end function

  ' /**
  ' * @name isNonEmptyArray
  ' * @description Checks if the supplied value is a valid Array type and not empty
  ' * @param {Dynamic} value The variable to be checked
  ' * @return {Boolean} Results of the check
  ' */
  function isNonEmptyArray(value as Dynamic) as Boolean
    return (_.isArray(value) AND NOT value.isEmpty())
  end function

  ' We dont need this, but adding for future support
  function isArrayBuffer(value as dynamic)
    return false
  end function

  ' /**
  ' * @name isArrayLike
  ' * @description Checks if the supplied value is a valid unempty Array like type
  ' * @param {Dynamic} value The variable to be checked
  ' * @return {Boolean} Results of the check
  ' */
  function isArrayLike(value as dynamic)
    return _.isNonEmptyArray(value) OR _.isNonEmptyAA(value) OR _.isNonEmptyString(value)
  end function

  ' /**
  ' * @name isByteArray
  ' * @description Checks if the supplied value is a valid ByteArray type
  ' * @param {Dynamic} value The variable to be checked
  ' * @return {Boolean} Results of the check
  ' */
  function isByteArray(value as dynamic)
    return type(value) = "roByteArray"
  end function

  ' /**
  ' * @name isBoolean
  ' * @description Checks if the supplied value is a valid Boolean type
  ' * @param {Dynamic} value The variable to be checked
  ' * @return {Boolean} Results of the check
  ' */
  function isBoolean(value as Dynamic) as Boolean
    valueType = type(value)
    return (valueType = "Boolean") OR (valueType = "roBoolean")
  end function

  ' /**
  ' * @name isBuffer
  ' * @description FUTURE PROOF - Checks if the supplied value is a valid Buffer type
  ' * @param {Dynamic} value The variable to be checked
  ' * @return {Boolean} Results of the check
  ' */
  function isBuffer(value as Dynamic) as Boolean
    return false
  end function

  ' /**
  ' * @name isDate
  ' * @description Alias to isDate function
  ' * @param {Dynamic} value The variable to be checked
  ' * @return {Boolean} Results of the check
  ' */
  function isDate(value as Dynamic) as Boolean
    return _.isDateTime(value)
  end function

  ' /**
  ' * @name isDate
  ' * @description Checks if the supplied value is a valid date time type
  ' * @param {Dynamic} value The variable to be checked
  ' * @return {Boolean} Results of the check
  ' */
  function isDateTime(value as Dynamic) as Boolean
    return ("roDateTime" = type(value))
  end function

  ' /**
  ' * @name isElement
  ' * @description Alias to isNode function
  ' * @param {Dynamic} value The variable to be checked
  ' * @param {String} subType An optional subType parameter to further refine the check
  ' * @return {Boolean} Results of the check
  ' */
  function isElement(value as Dynamic, subType = "" as String) as Boolean
    return _.isNode(value, subtype)
  end function

  ' /**
  ' * @name isNode
  ' * @description Checks if the supplied value is a valid Node type
  ' * @param {Dynamic} value The variable to be checked
  ' * @param {String} subType An optional subType parameter to further refine the check
  ' * @return {Boolean} Results of the check
  ' */
  function isNode(value as Dynamic, subType = "" as String) as Boolean
    if type(value) <> "roSGNode" then return false
    if subType <> "" then return value.isSubtype(subType)
    return true
  end function

  ' /**
  ' * @name isString
  ' * @description Checks if the supplied value is a valid String type
  ' * @param {Dynamic} value The variable to be checked
  ' * @return {Boolean} Results of the check
  ' */
  function isString(value as dynamic)
    valueType = type(value)
	  return (valueType = "String") OR (valueType = "roString")
  end function

  ' /**
  ' * @name isEmptyString
  ' * @description Checks if the supplied value is a valid String type and is not empty
  ' * @param {Dynamic} value The variable to be checked
  ' * @return {Boolean} Results of the check
  ' */
  function isEmptyString(value as Dynamic) as Boolean
    return _.isString(value) AND value = ""
  end function

  ' /**
  ' * @name isEmptyString
  ' * @description Checks if the supplied value is a valid String type and is not empty
  ' * @param {Dynamic} value The variable to be checked
  ' * @return {Boolean} Results of the check
  ' */
  function isNonEmptyString(value as Dynamic) as Boolean
    return _.isString(value) AND value <> ""
  end function

  function isEmpty(value as dynamic)
    if _.isInvalid(value) then return true
    if _.isNonEmptyArray(value) then return false
    if _.isEmptyString(value) then return true
    if _.isNumber(value) then return true
    if _.isNonEmptyAA(value) then return false
    if _.isBoolean(value) then return true

    return false
  end function

  ' /**
  ' * @name isEqual
  ' * @description Checks if the supplied values are the same.
  ' * @param {Dynamic} valueOne - First value.
  ' * @param {Dynamic} valueTwo - Second value.
  ' * @return {Boolean} True if the values are the same and false if not or if any of the values are a type that could not be compared.
  ' */
  function isEqual(valueOne as Dynamic, valueTwo as Dynamic) as Boolean
    ' If the first argument is true we don't need to check the follwing conditionals
    if _.canBeCompared(valueOne, valueTwo) then
      return (valueOne = valueTwo)
    else if _.isNode(valueOne) then
      if _.isNode(valueTwo) then return valueOne.isSameNode(valueTwo)
    else if _.isAA(valueOne) then
      if _.isAA(valueTwo) AND (_.join(valueOne.keys(), ",") = _.join(valueTwo.keys(), ",")) then return (formatJson(valueOne) = formatJson(valueTwo))
    else if _.isArray(valueOne) then
      if _.isArray(valueTwo) AND (valueOne.count() = valueTwo.count()) then return (formatJson(valueOne) = formatJson(valueTwo))
    end if

    return false
  end function

  ' /**
  ' * @name isEqualWith
  ' * @description Checks if the supplied values are the same.
  ' * @param {Dynamic} valueOne - First value.
  ' * @param {Dynamic} valueTwo - Second value.
  ' * @return {Boolean} True if the values are the same and false if not or if any of the values are a type that could not be compared.
  ' */
  function isEqualWith(valueOne as Dynamic, valueTwo as Dynamic, customizer = invalid) as Boolean
    ' If the first argument is true we don't need to check the follwing conditionals
    ' TODO: revisit this agressively
    if _.canBeCompared(valueOne, valueTwo) then
      return customizer(valueOne, valueTwo)
    else if _.isNode(valueOne) then
      if _.isNode(valueTwo) then
        valueOne = valueOne.getFields()
        valueOne.delete("change")
        valueOne.delete("focusable")
        valueOne.delete("focusedChild")
        valueOne.delete("ready")

        valueTwo = valueTwo.getFields()
        valueTwo.delete("change")
        valueTwo.delete("focusable")
        valueTwo.delete("focusedChild")
        valueTwo.delete("ready")

        return _.isEqualWith(valueOne, valueTwo, customizer)
      end if
    else if _.isAA(valueOne) then
      if _.isAA(valueTwo) AND (valueOne.keys().count() = valueTwo.keys().count()) then
        keys = valueOne.keys()

        for each key in keys
          if customizer(valueOne[key], valueTwo[key]) then return true
        end for
      end if
    else if _.isArray(valueOne) then
      if _.isArray(valueTwo) AND (valueOne.count() = valueTwo.count()) then
        for i = 0 to valueOne.count() -1
          if customizer(valueOne[i], valueTwo[i]) then return true
        end for
      end if
    end if

    return false
  end function

  ' /**
  ' * @name isError
  ' * @description Assesses the passed object to determine if it is an Error Object.
  ' * @param {Dynamic} value - the object to assess
  ' * @return {Boolean} True if the object represents and error.
  ' */
  ' TODO: MORE SUPPORT - TRY/CATCH?
  function isError(value as dynamic) as boolean
    if _.isAA(value) then
      if _.isNonEmptyString(value.status) AND _.stringIncludes(value.status, "error") then return true

      errorCodes = _.internal.bslBrightScriptErrorCodes()
      if _.hasKeys(value, ["number", "message", "exception"]) then
        for each errorCode in errorCodes
          if value.number = errorCode then return true
        end for
      end if
    end if
    return false
  end function

  function isFinite(value as dynamic) as boolean
    if NOT _.isNumber(value) then return false

    if _.gt(value, _.internal.bslGeneralConstants().max_int) OR _.lt(value, _.internal.bslGeneralConstants().min_int) then return false

    return true
  end function

  ' /**
  ' * @description Alias to isInvalid function
  ' * @param {Dynamic} value The variable to be checked
  ' * @return {Boolean} Results of the check
  ' */
  function isNull(value as Dynamic) as Boolean
    return NOT _.isNotInvalid(value)
  end function

  ' /**
  ' * @description Checks if the supplied value is Invalid
  ' * @param {Dynamic} value The variable to be checked
  ' * @return {Boolean} Results of the check
  ' */
  function isInvalid(value as Dynamic) as Boolean
    return NOT _.isNotInvalid(value)
  end function

  ' /**
  ' * @name isNotInvalid
  ' * @description Checks if the supplied value is not Invalid or uninitialized
  ' * @param {Dynamic} value The variable to be checked
  ' * @return {Boolean} Results of the check
  ' */
  function isNotInvalid(value as Dynamic) as Boolean
    return (type(value) <> "<uninitialized>" AND value <> Invalid)
  end function

  ' /**
  ' * @name isNumber
  ' * @description Checks if the supplied value is a valid number type
  ' * @param {Dynamic} value The variable to be checked
  ' * @return {Boolean} Results of the check
  ' */
  function isNumber(obj as Dynamic) as Boolean
    if (_.isInteger(obj)) then return true
    if (_.isFloat(obj)) then return true
    if (_.isDouble(obj)) then return true
    return false
  end function

  ' /**
  ' * @name isInteger
  ' * @description Checks if the supplied value is a valid Integer type
  ' * @param {Dynamic} value The variable to be checked
  ' * @return {Boolean} Results of the check
  ' */
  function isInteger(value as Dynamic) as boolean
    valueType = type(value)
    return (valueType = "Integer") OR (valueType = "roInt") OR (valueType = "roInteger") OR (valueType = "LongInteger")
  end function

  ' /**
  ' * @name isLength
  ' * @description Checks if value is a valid array-like length
  ' * @param {Dynamic} value The variable to be checked
  ' * @return {Boolean} Results of the check
  ' */
  function isLength(value as dynamic) as boolean
    if _.isInteger(value) AND _.isFinite(value) AND _.gte(value, 0) then return true
    return false
  end function

  ' /**
  ' * @name isMap
  ' * @description Alias to isArray function
  ' * @param {Dynamic} value The variable to be checked
  ' * @return {Boolean} Results of the check
  ' */
  function isMap(value as dynamic) as boolean
    return _.isArray(value)
  end function

    ' /**
  ' * @name isNaN
  ' * @description Method determines whether the passed value is NaN and its type is a valid number
  ' * @param {Dynamic} value The variable to be checked
  ' * @return {Boolean} Results of the check
  ' */
  function isNaN(value as dynamic) as boolean
    return NOT _.isNumber(value)
  end function

  ' TODO: see if you can support this
  function isNative(value = invalid)
    return false
  end function

  ' /**
  ' * @name isFloat
  ' * @description Checks if the supplied value is a valid Float type
  ' * @param {Dynamic} value The variable to be checked
  ' * @return {Boolean} Results of the check
  ' */
  function isFloat(value as Dynamic) as Boolean
    valueType = type(value)
    return (valueType = "Float") OR (valueType = "roFloat")
  end function

  ' /**
  ' * @name isDouble
  ' * @description Checks if the supplied value is a valid Double type
  ' * @param {Dynamic} value The variable to be checked
  ' * @return {Boolean} Results of the check
  ' */
  function isDouble(value as Dynamic) as Boolean
    valueType = type(value)
    return (valueType = "Double") OR (valueType = "roDouble") OR (valueType = "roIntrinsicDouble")
  end function

  
  function lt(value as dynamic, other as dynamic)
    return value < other
  end function

  function lte(value as dynamic, other as dynamic)
    return value <= other
  end function

  ' /**
  ' * @name toNumber
  ' * @description Attempts to convert the supplied value into a valid number
  ' * @param {Dynamic} value The variable to be converted
  ' * @return {Dynamic} Results of the conversion
  ' */
  function toNumber(value as Dynamic) as Dynamic
    if _.isNumber(value) then
      return value
    else if _.isBoolean(value) then
      if value then return 1
      return 0
    end if

    if _.isString(value) then
      ' TODO: Temporary fix until we figure a better way to avoid val converting 8037667 to 8.03767e+06
      if _.stringIncludes(value, ".") then
        return val(value)
      else
        return val(value, 10)
      end if
    end if

    return 0
  end function

  '*************************************************************************
  '#endregion *** LANG
  '*************************************************************************


  '*************************************************************************
  '#region *** ASSOC ARRAY / OBJECT
  '*************************************************************************

  ' /**
  ' * @name assign
  ' * @description Assigns own enumerable string keyed properties of source objects to the destination object. Source objects are applied from left to right. Subsequent sources overwrite property assignments of previous sources.
  ' * This method mutates object and is loosely based on Object.assign.
  ' * @param {Dynamic} baseAA - The destination object
  ' * @return {Object} sources - The source objects
  ' */
  function assign(baseAA as Dynamic, sources = [] as Object) as Dynamic
    if NOT _.isAA(baseAA) then return Invalid

    for each source in sources
      if _.isAA(source) then
        baseAA.append(source)
      end if
    end for

    return baseAA
  end function

  ' TODO: Figure out what to do here
  function assignIn(baseAA as Dynamic, sources = [] as Object) as Dynamic
    return _.assign(baseAA, sources)
  end function

  ' TODO: Figure out what to do here
  function assignInWith(baseAA as Dynamic, sources = [] as Object) as Dynamic
    return _.assign(baseAA, sources)
  end function

  ' TODO: Figure out what to do here
  function assignWith(baseAA as Dynamic, sources = [] as Object) as Dynamic
    return _.assign(baseAA, sources)
  end function

  function at(obj = {} as object, paths = [] as object)
    returnArray = []

    for each path in paths
      result = _.getValueAtKeyPath(obj, path)
      returnArray.push(result)
    end for

    return returnArray
  end function

  ' /**
  ' * @name forIn
  ' * @description Iterates over own and inherited enumerable string keyed properties of an object and invokes iteratee for each property. The iteratee is invoked with three arguments: (value, key, object). Iteratee functions may exit iteration early by explicitly returning false.
  ' * @param {Dynamic} obj - The object to iterate over
  ' * @param {Dynamic} iteratee - The function invoked per iteration
  ' * @return {Object} Returns object
  ' */
  function forIn(obj = {} as dynamic, iteratee = invalid as dynamic)
    return _.base.forEach.baseForEach(collection, iteratee)
  end function

  ' /**
  ' * @name getValueAtKeyPath
  ' * @description Used to find a nested value in an object
  ' * @param {Object} aa Object to drill down into.
  ' * @param {String} keyPath A dot notation based string to the expected value.
  ' * @param {Dynamic} fallback A return fallback value if the requested field could not be found or did not pass the validator function.
  ' * @param {Function} validator A function used to validate the output value matches what you expected.
  ' * @return {Dynamic} The result of the drill down process
  ' */
  function getValueAtKeyPath(aa as Object, keyPath as String, fallback = Invalid as Dynamic, validator = isNotInvalid as Function) as Dynamic
    if NOT (_.isKeyedValueType(aa) OR _.isNonEmptyArray(aa)) OR keyPath = "" then return fallback

    nextValue = aa
    keyPath = _.sanitizeKeyPathArray(keyPath)
    keys = keyPath.tokenize(".").toArray()
    startingKeys = _.join(keys, " - ")
    for each key in keys
      if _.isKeyedValueType(nextValue) then
        nextValue = nextValue[key]
      else if _.isNonEmptyArray(nextValue) then
        nextValue = nextValue[_.toNumber(key)]
      else
        return fallback
      end if
    end for

    if NOT validator(nextValue) then return fallback

    return nextValue
  end function

  function sanitizeKeyPathArray(value = "" as String)
    regex = createObject("roRegex", "\[(.*?)\]", "i")
    matches = regex.matchAll(value)

    if _.isNotInvalid(matches) then
      for each match in matches
        if _.isNotInvalid(match) then
          value = value.replace(match[0], "." + match[1])
        end if
      end for
    end if

    return 	value
  end function

  ' /**
  ' * @name setValueAtKeyPath
  ' * @description Used to set a nested String value in the supplied object
  ' * @param {Object} aa - Object to drill down into.
  ' * @param {String} keyPath - A dot notation based string to the expected value.
  ' * @param {Dynamic} value - The value to be set.
  ' * @return {Boolean} True if set successfully.
  ' */
  function setValueAtKeyPath(aa as Object, keyPath as String, value as Dynamic) as Boolean
    if NOT _.isAA(aa) then return false

    level = aa
    keys = _.sanitizeKeyPathArray(keyPath).tokenize(".")
    while keys.count() > 1
      key = keys.shift()
      if NOT _.isAA(level[key]) then level[key] = {}
      level = level[key]
    end while

    finalKey = keys.shift()
    level[finalKey] = value
    return true
  end function

  ' TODO: add support
  function create()
    return {}
  end function

  ' TODO: add support
  function defaults()
    return {}
  end function

  ' /**
  ' * @name hasKeys
  ' * @description Checks if first level of the supplied AssociativeArray contains the Array of key strings.
  ' * @param {Dynamic} aaValue - AssociativeArray to be checked
  ' * @return {Dynamic} keys - Array of key strings
  ' */
  function hasKeys(aaValue as dynamic, keys as dynamic) as boolean
    if NOT _.isKeyedValueType(aaValue) OR aaValue.isEmpty() OR NOT _.isArray(keys) OR keys.isEmpty() then return false

    hasKeys = true
    for each key in keys
      if NOT aaValue.doesExist(key) then
        hasKeys = false
        exit for
      end if
    end for

    return hasKeys
  end function

  '*************************************************************************
  '#endregion *** ASSOC ARRAY / OBJECT
  '*************************************************************************


  '*************************************************************************
  '#region *** STRING
  '*************************************************************************

  function camelCase(value = "" as string)
    value = value.replace("-", " ").replace("_", " ")
    value = value.trim()
    valueArray = value.split(" ")
    responseValue = ""

    for i = 0 to valueArray.count() -1
      valueString = valueArray[i]

      if i = 0 then
        responseValue += lcase(valueString)
      else
        responseValue += _.capitalize(valueString)
      end if
    end for

    return responseValue
  end function

  function capitalize(value = "" as string)
    value = value.trim()
    valueArray = value.split("")
    responseValue = ""

    for i = 0 to valueArray.count() -1
      valueString = valueArray[i]

      if i = 0 then
        responseValue += ucase(valueString)
      else
        responseValue += lcase(valueString)
      end if
    end for

    return responseValue
  end function

  ' TODO: Add support
  function deburr(value = "" as string)

    return value
  end function

  function endsWith(source = "" as string, target = "" as string, position = invalid as dynamic)
    if _.isInvalid(position) then position = source.len()

    return source.endsWith(target, position)
  end function

  function escape(source = "" as string)
    return source.escape()
  end function

  function escapeRegExp(source = "" as string)
    replaceArray = ["^", "$", "", ".", "*", "+", "?", "(", ")", "[", "]", "{", "}", "|"]
    for each char in replaceArray
      source = source.replace(char, "\"+char)
    end for
    return source.replace("\/\/", "//")
  end function

  function kebabCase(value = "" as string)
    value = value.replace("-", " ").replace("_", " ")
    value = value.trim()
    valueArray = value.split(" ")
    return lcase(_.join(valueArray,"-"))
  end function

  function lowerCase(value = "" as string)
    value = value.replace("-", " ").replace("_", " ")
    value = value.trim()
    valueArray = value.split(" ")
    return lcase(_.join(valueArray, " "))
  end function

  function lowerFirst(value = "" as string)
    value = value.trim()
    valueArray = value.split("")
    valueArray[0] = lcase(valueArray[0])
    return _.join(valueArray)
  end function

  ' /**
  ' * @name paddString
  ' * @description Add padding to the supplied value after converting to a string. For example "1" to "01".
  ' * @param {String} value The value to add padding to.
  ' * @param {Integer} padLength The minimum output string length.
  ' * @param {String} paddingCharacter The string to use as padding.
  ' * @return {String} Resulting padded string.
  ' */
  function paddString(value as Dynamic, padLength = 2 as Integer, paddingCharacter = "0" as Dynamic) as String
    value = _.toString(value)
    while value.len() < padLength
      value = paddingCharacter + value
    end while
    return value
  end function

  ' /**
  ' * @name stringIndexOf
  ' * @description Finds the sub string index position
  ' * @param {String} value The string to search
  ' * @param {String} subString The sub string to search for
  ' * @return {Integer} Results of the search
  ' */
  function stringIndexOf(value as String, subString as String) as Integer
    return value.Instr(subString)
  end function

  ' /**
  ' * @name stringIncludes
  ' * @description Check for the existence of a given sub string
  ' * @param {String} value The string to search
  ' * @param {String} subString The sub string to search for
  ' * @return {Boolean} Results of the search
  ' */
  function stringIncludes(value as String, subString as String) as Boolean
    return _.stringIndexOf(value, subString) > -1
  end function

  ' /**
  ' * @name toString
  ' * @description Attempts to convert the supplied value to a string.
  ' * @param {Dynamic} value The value to convert.
  ' * @return {String} Results of the conversion.
  ' */
  function toString(value as Dynamic) as String
    if _.isString(value) then return value
    if _.isNumber(value) then return _.numberToString(value)
    if _.isNode(value) then return _.nodeToString(value)
    if _.isBoolean(value) then return _.booleanToString(value)
    if _.isAA(value) then return _.aaToString(value)
    if _.isArray(value) then return _.arrayToString(value)
    return ""
  end function

  ' /**
  ' * @name numberToString
  ' * @description Attempts to convert the supplied value to a string.
  ' * @param {Dynamic} value The value to convert.
  ' * @return {String} Results of the conversion.
  ' */
  function numberToString(value as Dynamic) as String
    return value.toStr()
  end function

  ' /**
  ' * @name aaToString
  ' * @description Attempts to convert the supplied value to a string.
  ' * @param {Dynamic} value The value to convert.
  ' * @return {String} Results of the conversion.
  ' */
  function aaToString(aa as Object) as String
    description = "{"
    for each key in aa
      description += key + ": " + _.toString(aa[key]) + ", "
    end for
    description = description.left(description.len() - 2) + "}"
    return description
  end function

  ' /**
  ' * @name aaToArray
  ' * @description Attempts to convert the supplied value to a array.
  ' * @param {Dynamic} value The value to convert.
  ' * @return {Object} Results of the conversion.
  ' */
  function aaToArray(aa as Object) as Object
    array = []
    for each key in aa
      value = aa[key]
      index = _.getValueAtKeyPath(value, "index")
      if _.isNumber(index) then
        array.setEntry(index, value)
      else
        array.push(value)
      end if
    end for

    return array
  end function

  ' /**
  ' * @name arrayToString
  ' * @description Attempts to convert the supplied value to a string.
  ' * @param {Dynamic} value The value to convert.
  ' * @return {String} Results of the conversion.
  ' */
  function arrayToString(array as Object) as String
    description = "["
    for each item in array
      description += _.toString(item) + ", "
    end for
    description = description.left(description.len() - 2) + "]"
    return description
  end function

  ' /**
  ' * @name booleanToString
  ' * @description Attempts to convert the supplied value to a string.
  ' * @param {Dynamic} value The value to convert.
  ' * @return {String} Results of the conversion.
  ' */
  function booleanToString(bool as Boolean) as String
    if bool then return "true"
    return "false"
  end function

  ' /**
  ' * @name nodeToString
  ' * @description Attempts to convert the supplied value to a string.
  ' * @param {Dynamic} value The value to convert.
  ' * @return {String} Results of the conversion.
  ' */
  function nodeToString(node as Object) as String
    if NOT _.isNode(node) then return ""

    description = node.subtype()
    if node.isSubtype("Group") then
      ' accessing properties from anywhere but the render thread is too expensive to include here
      id = node.id
      if id <> "" then
        description += " (" + id + ")" + _.aaToString(_.nodeToAA(node))
      end if
    end if
    return description
  end function

  ' /**
  ' * @name nodeToAA
  ' * @description Attempts to converts a nodes top level fields to an AssociativeArray.
  ' * @param {Dynamic} value - The variable to be converted.
  ' * @param {Boolean} removeId - If set to true the nodes ID will also be stripped.
  ' * @param {Object} removeFields - List of keys that need to be removed from the node.
  ' * @return {Dynamic} Results of the conversion.
  ' */
  function nodeToAA(value as Object, removeId = false as Boolean, removeFields = [] as Object) as Object
    if _.isNode(value) then
      fields = value.getFields()
      fields.delete("change")
      fields.delete("focusable")
      fields.delete("focusedChild")
      fields.delete("ready")
      if removeId then fields.delete("id")
      'Looping through any additional fields if passed.
      if _.isNonEmptyArray(removeFields) then
        for each field in removeFields
          fields.delete(field)
        end for
      end if
      return fields
    else if _.isAA(value) then
      return value
    end if

    return {}
  end function

  '*************************************************************************
  '#endregion *** STRING
  '*************************************************************************


  '*************************************************************************
  '#region *** MATH
  '*************************************************************************

  ' /**
  ' * @name add
  ' * @description Adds two numbers
  ' * @param {Dymanic} augend - The first number in an addition
  ' * @param {Dymanic} addend - The second number in an addition
  ' * @return {Integer} Returns the total
  ' */
  function add(augend, addend)
    value = 0
    if _.isNumber(augend) then value += augend
    if _.isNumber(addend) then value += addend

    return value
  end function

  ' /**
  ' * @name ceil
  ' * @description Computes number rounded up to precision.
  ' * @param {Integer} number - The number to round up
  ' * @param {Integer} precision - The precision to round up to
  ' * @return {Integer} Returns the rounded up number
  ' */
  function ceil(number = 0, precision = 0 as integer)
    return -int(-number * 10^precision) / 10^precision
  end function

  ' /**
  ' * @name divide
  ' * @description Divides two numbers
  ' * @param {Dymanic} dividend - The first number in a division
  ' * @param {Dymanic} divisor - The second number in a division
  ' * @return {Integer} Returns the quotient
  ' */
  function divide(dividend = 0 as dynamic, divisor = 0 as dynamic) as dynamic
    if _.isNan(dividend) OR _.isNan(divisor) return 0
    if _.lte(divisor, 0) then return dividend

    return dividend / divisor
  end function

  ' /**
  ' * @name floor
  ' * @description Computes number rounded down to precision
  ' * @param {Integer} number - The number to round down
  ' * @param {Integer} precision - The precision to round down to
  ' * @return {Integer} Returns the rounded down number
  ' */
  function floor(number = 0, precision = 0 as integer)
    return int(number * 10^precision) / 10^precision
  end function

  ' /**
  ' * @name max
  ' * @description Computes the maximum value of array. If array is empty or falsey, invalid is returned.
  ' * @param {Array} array - The array to iterate over
  ' * @return {Dynamic} Returns the maximum value
  ' */
  function max(array = [] as object) as dynamic
    return _.maxBy(array)
  end function

  ' /**
  ' * @name maxBy
  ' * @description Computes the maximum value of array. If array is empty or falsey, invalid is returned.
  ' * @param {Array} array - The array to iterate over
  ' * @return {Dynamic} Returns the maximum value
  ' */
  function maxBy(array = [] as object, iteratee = invalid) as dynamic
    if _.isEmpty(array) then return invalid

    maxValue = invalid
    if _.isInvalid(iteratee) then
      maxValue = _.internal.bslGeneralConstants().min_int
      for each value in array
        if _.gt(value, maxValue) then maxValue = value
      end for
    else if _.isFunction(iteratee) AND _.isAA(array[0]) then
      maxValue = array[0]
      for each value in array
        if _.gt(iteratee(value), iteratee(maxValue)) then maxValue = value
      end for
    else if _.isString(iteratee) AND _.isAA(array[0]) then
      maxValue = array[0]
      for each value in array
        if _.gt(value[iteratee], maxValue[iteratee]) then maxValue = value
      end for
    end if

    return maxValue
  end function


  function mean(array)
    return _.meanBy(array)
  end function


  function meanBy(array, iteratee = invalid)
    if _.isEmpty(array) then return invalid

    return _.divide(_.sumBy(array, iteratee), array.count())
  end function

  ' /**
  ' * @name min
  ' * @description Computes the minimum value of array. If array is empty or falsey, invalid is returned.
  ' * @param {Array} array - The array to iterate over
  ' * @return {Dynamic} Returns the minumum value
  ' */
  function min(array = [] as object) as dynamic
    return _.minBy(array)
  end function

  ' /**
  ' * @name minBy
  ' * @description Computes the minimum value of array. If array is empty or falsey, invalid is returned.
  ' * @param {Array} array - The array to iterate over
  ' * @return {Dynamic} Returns the maximum value
  ' */
  function minBy(array = [] as object, iteratee = invalid) as dynamic
    if _.isEmpty(array) then return invalid

    minValue = invalid
    if _.isInvalid(iteratee) then
      minValue = _.internal.bslGeneralConstants().max_int
      for each value in array
        if _.lt(value, minValue) then minValue = value
      end for
    else if _.isFunction(iteratee) AND _.isAA(array[0]) then
      minValue = array[0]
      for each value in array
        if _.lt(iteratee(value), iteratee(minValue)) then minValue = value
      end for
    else if _.isString(iteratee) AND _.isAA(array[0]) then
      minValue = array[0]
      for each value in array
        if _.lt(value[iteratee], minValue[iteratee]) then minValue = value
      end for
    end if

    return minValue
  end function

  function multiply(multiplier as dynamic, multiplicand as dynamic) as dynamic
    if _.isNan(multiplier) OR _.isNan(multiplicand) return 0

    return multiplier * multiplicand
  end function

  function round(number = 0, precision = 0 as integer)
    minor = number.toStr().split(".")[1]
    ?_.isNotInvalid(minor), minor

    return _.ceil(number, precision)
  end function

  function subtract(minuend as dynamic, subtrahend as dynamic) as dynamic
    if _.isNan(minuend) OR _.isNan(subtrahend) return 0

    return minuend - subtrahend
  end function

  function sum(array as object)
    sumValue = 0

    for each item in array
      sumValue += item
    end for

    return sumValue
  end function

  function sumBy(array = [] as object, iteratee = invalid) as dynamic
    if _.isEmpty(array) then return invalid

    sumValue = invalid
    if _.isInvalid(iteratee) then
      sumValue = 0
      for each value in array
        sumValue += value
      end for
    else if _.isFunction(iteratee) AND _.isAA(array[0]) then
      sumValue = 0
      for each value in array
        sumValue += iteratee(value)
      end for
    else if _.isString(iteratee) AND _.isAA(array[0]) then
      sumValue = 0
      for each value in array
        sumValue += value[iteratee]
      end for
    end if

    return sumValue
  end function

  '*************************************************************************
  '#endregion *** MATH
  '*************************************************************************


  '*************************************************************************
  '#region *** NUMBER
  '*************************************************************************

  function clamp(number, lower, upper) as dynamic
    return _.max([lower, _.min([upper, number])])
  end function

  function inRange(number as dynamic, startPos = 0 as dynamic, endPos = invalid as dynamic)
    if (_.isInvalid(endPos)) then
      endPos = startPos
      startPos = 0
    end if

    if _.gt(startPos, endPos) then
      startPosTemp = startPos
      endPosTemp = endPos

      startPos = endPosTemp
      endPos = startPosTemp
    end if
  
    return _.gte(number, startPos) AND _.lt(number, endPos)
  end function

  function random(lower = 0 as dynamic, upper = 1 as dynamic, floating = invalid) as dynamic
    offset = rnd(0)

    if (_.isBoolean(upper)) then
      floating = upper
      upper = 1
    end if

    inputValueIsFloat = _.isFloat(lower) OR _.isFloat(upper)
    respectFloating = _.isBoolean(floating) OR inputValueIsFloat
    if respectFloating AND _.isInvalid(floating) then
      floating = inputValueIsFloat
    end if

    roundLower = rnd(lower)
    roundUpper = rnd(upper)

    roundValue = _.add(roundLower, roundUpper)
    if _.gt(roundValue, upper) then roundValue = roundUpper
    if _.lt(roundValue, lower) then roundValue = roundLower

    if _.isInvalid(floating) OR (respectFloating AND NOT floating) then
      roundValue = cint(roundValue)
    else
      roundValue = ((roundValue - offset).toStr() + "." + offset.toStr()).toFloat()
    end if

    return roundValue
  end function

  '*************************************************************************
  '#endregion *** NUMBER
  '*************************************************************************


  '*************************************************************************
  '#region *** UTIL
  '*************************************************************************

  '*************************************************************************
  '#endregion *** UTIL
  '*************************************************************************
end namespace


namespace _.internal
  '*************************************************************************
  '#region *** BSC DATA
  '*************************************************************************
  ' ? ReadAsciiFile("common:/LibCore/v30/bslCore.brs")
  function bslBrightScriptErrorCodes()
    return {
      ' runtime errors
      ERR_OKAY          :  &hFF
      ERR_NORMAL_END    :  &hFC         ' normal, but terminate execution.  END, shell "exit", window closed, etc.
      ERR_VALUE_RETURN  :  &hE2         ' return executed, and a value returned on the stack
      ERR_INTERNAL      :  &hFE         ' A condition that shouldn't occur did
      ERR_UNDEFINED_OPCD:  &hFD         ' A opcode that we don't handle
      ERR_UNDEFINED_OP  :  &hFB         ' An expression operator that we don't handle
      ERR_MISSING_PARN  :  &hFA
      ERR_STACK_UNDER   :  &hF9         ' nothing on stack to pop
      ERR_BREAK         :  &hF8         ' scriptBreak() called
      ERR_STOP          :  &hF7         ' stop statement executed
      ERR_RO0           :  &hF6         ' bscNewComponent failed because object class not found
      ERR_RO1           :  &hF5         ' ro function call does not have the right number of parameters
      ERR_RO2           :  &hF4         ' member function not found in object or interface
      ERR_RO3           :  &hF3         ' Interface not a member of object
      ERR_TOO_MANY_PARAM    :  &hF2     ' Too many function parameters to handle
      ERR_WRONG_NUM_PARAM   :  &hF1     ' Incorect number of function parameters
      ERR_RVIG              :  &hF0     ' Function returns a value, but is ignored
      ERR_NOTPRINTABLE      :  &hEF     ' Non Printable value
      ERR_NOTWAITABLE       :  &hEE     ' Tried to Wait on a function that does not have MessagePort interface
      ERR_MUST_BE_STATIC    :  &hED     ' interface calls from type rotINTERFACE must by static
      ERR_RO4               :  &hEC     ' . operator used on a variable that does not contain a legal object or interface reference
      ERR_NOTYPEOP          :  &hEB     ' operation on two typless operands attempted
      ERR_USE_OF_UNINIT_VAR :  &hE9     ' illegal use of uninited var
      ERR_TM2               :  &hE8     ' non-numeric index to array
      ERR_ARRAYNOTDIMMED    :  &hE7
      ERR_USE_OF_UNINIT_BRSUBREF :  &hE6    ' used a reference to SUB that is not initilized
      ERR_MUST_HAVE_RETURN  :  &hE5
      ERR_INVALID_LVALUE    :  &hE4     ' invalid left side of expression
      ERR_INVALID_NUM_ARRAY_IDX :  &hE3 ' invalid number of array indexes
      ERR_UNICODE_NOT_SUPPORTED :  &hE1
      ERR_NOTFUNOPABLE      :  &hE0
      ERR_STACK_OVERFLOW    :  &hDF
      ERR_THROWN_EXCEPTION_ON_STACK     : &hDE  '(Internal use only)
      ERR_SYNTAX            :  &h02
      ERR_DIV_ZERO          :  &h14
      ERR_MISSING_LN        :  &h0E
      ERR_OUTOFMEM          :  &h0C
      ERR_STRINGTOLONG      :  &h1C
      ERR_TM                :  &h18     ' Type Mismatch (string / numeric operation mismatch)
      ERR_OS                :  &h1A     ' out of string space
      ERR_RG                :  &h04     ' Return without Gosub
      ERR_NF                :  &h00     ' Next without For
      ERR_FC                :  &h08     ' Invalid parameter passed to function/array (e.g neg matrix dim or squr root)
      ERR_DD                :  &h12     ' Attempted to redimension an array
      ERR_BS                :  &h10     ' Array subscript out of bounds
      ERR_OD                :  &h06     ' Out of Data (READ)
      ERR_CN                :  &h20     ' Continue Not Allowed
      ERR_BITSHIFT_BAD      :  &h1E     ' Invalid Bitwise Shift
      ERR_EXECUTION_TIMEOUT :  &h23     ' Timeout on critical thread
      ERR_CONSTANT_OVERFLOW :  &h22     ' Constant Out Of Range
      ERR_FORMAT_SPECIFIER  :  &h24     ' Invalid Format Specifier
      ERR_BAD_THROW         :  &h26     ' Invalid argument to Throw
      ERR_USER              :  &h28     ' User-specified exception

    ' compiler errors
      ERR_NW                :  &hBF     ' EndWhile with no While
      ERR_MISSING_ENDWHILE  :  &hBE     ' While Statement is missing a matching EndWhile
      ERR_MISSING_ENDIF     :  &hBC     ' end of code reached without finding ENDIF
      ERR_NOLN              :  &hBB     ' no line number found
      ERR_LNSEQ             :  &hBA     ' Line number sequence error
      ERR_LOADFILE          :  &hB9     ' Error loading a file
      ERR_NOMATCH           :  &hB8     ' "Match" statement did not match
      ERR_UNEXPECTED_EOF    :  &hB7     ' End of string being compiled encountered when not expected (missing end of block usually)
      ERR_FOR_NEXT_MISMATCH :  &hB6     ' Variable on a NEXT does not match that for the FOR
      ERR_NO_BLOCK_END      :  &hB5
      ERR_LABELTWICE        :  &hB4     ' Label defined more than once
      ERR_UNTERMED_STRING   :  &hB3     ' litteral string does not have ending quote
      ERR_FUN_NOT_EXPECTED  :  &hB2
      ERR_TOO_MANY_CONST    :  &hB1
      ERR_TOO_MANY_VAR      :  &hB0
      ERR_EXIT_WHILE_NOT_IN_WHILE   :  &hAF
      ERR_INTERNAL_LIMIT_EXCEDED    :  &hAE
      ERR_SUB_DEFINED_TWICE :  &hAD
      ERR_NOMAIN            :  &hAC
      ERR_FOREACH_INDEX_TM  :  &hAB
      ERR_RET_CANNOT_HAVE_VALUE     :  &hAA
      ERR_RET_MUST_HAVE_VALUE       :  &hA9
      ERR_FUN_MUST_HAVE_RET_TYPE    :  &hA8
      ERR_INVALID_TYPE              :  &hA7
      ERR_NOLONGER                  :  &hA6 ' no longer supported
      ERR_EXIT_FOR_NOT_IN_FOR       :  &hA5
      ERR_MISSING_INITILIZER        :  &hA4
      ERR_IF_TOO_LARGE              :  &hA3
      ERR_RO_NOT_FOUND              :  &hA2
      ERR_TOO_MANY_LABELS           :  &hA1
      ERR_VAR_CANNOT_BE_SUBNAME     :  &hA0
      ERR_INVALID_CONST_NAME        :  &h9F
      ERR_CONST_FOLDING             :  &h9E
      ERR_BUILTIN_FUNCTION          :  &h9D
      ERR_FUNCTION_NOT_IN_NAMESPACE :  &h91
      ERR_EVAL_UNSUPPORTED          :  &h90
      ERR_LABEL_INSIDE_TRY          :  &h8F
    }
  end function

  function bslGeneralConstants()
    return {
      MAX_INT :  2147483647
      MIN_INT : -2147483648
    }
  end function

  '*************************************************************************
  '#endregion *** BSC DATA
  '*************************************************************************
end namespace


namespace _.base.forEach
  ' /**
  ' * @name baseForEach
  ' * @description The base implementation of `forEach`.
  ' * @param {Array|Object} - collection The collection to iterate over
  ' * @param {Function} iteratee The function invoked per iteration
  ' * @return {Array|Object} Returns `collection`
  ' */
  function baseForEach(collection = invalid as dynamic, iteratee = invalid as dynamic, direction = "left")
    if _.isInvalid(collection) OR _.isEmpty(collection) then return invalid

    isRight = direction = "right"
    if _.isAA(collection) then
      keys = collection.keys()
      if isRight then keys.reverse()
      for each key in keys
        item = collection[key]
        if _.isFunction(iteratee) then iteratee(item, key)
      end for
    else
      if isRight then collection.reverse()
      for each item in collection
        if _.isFunction(iteratee) then iteratee(item)
      end for
      if isRight then collection.reverse()
    end if

    return true
  end function
end namespace